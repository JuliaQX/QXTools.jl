<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Miscellaneous Features · QXTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaQX.github.io/QXTools.jl/features/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QXTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QXTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../users_guide/">User&#39;s Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../basics/">Introduction</a></li><li><a class="tocitem" href="../circuits/">Circuits with QXZoo and YaoQX</a></li><li class="is-active"><a class="tocitem" href>Miscellaneous Features</a><ul class="internal"><li><a class="tocitem" href="#Hypergraphs"><span>Hypergraphs</span></a></li><li><a class="tocitem" href="#Slicing"><span>Slicing</span></a></li><li><a class="tocitem" href="#QXContexts-output"><span>QXContexts output</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../distributed/">Running Distributed Simulations</a></li></ul></li><li><a class="tocitem" href="../license/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Miscellaneous Features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Miscellaneous Features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQX/QXTools.jl/blob/master/docs/src/features.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Miscellaneous-Features"><a class="docs-heading-anchor" href="#Miscellaneous-Features">Miscellaneous Features</a><a id="Miscellaneous-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-Features" title="Permalink"></a></h1><p>In this tutorial we cover some of the features <code>QXTools</code> has to improve quantum circuit simulations and how to specify the type of output we would like our simulations to generate.</p><h2 id="Hypergraphs"><a class="docs-heading-anchor" href="#Hypergraphs">Hypergraphs</a><a id="Hypergraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Hypergraphs" title="Permalink"></a></h2><p>One feature that <code>QXTools</code> uses by default is that of <a href="https://arxiv.org/abs/1710.05867">hypergraphs</a>. The hypergraph for a given tensor network is a graph, representing the network topology, whose nodes correspond to tensors in the network and edges correspond to indices in the network that connect different tensors. Note, two indices in the netwrok may be associated with the same edge in the hypergraph if they both connect to a diagonal tensor and are identical as a result. The tensor network topology can also be represented using an ordinary graph but it typically requires a greater number of edges to do so.</p><p>This is useful because to find an efficient contraction plan for a given tensor network, <code>QXTools</code> first creates a line graph for the network topology and then runs the FlowCutter algorithm to find a tree decompostion for that line graph which can be converted into a contraction plan. Running FlowCutter on smaller graphs often results in more efficient contraction plans, with a smaller treewidth, in a shorter amount of time.</p><p><code>QXTools</code>, together with <code>QXTns</code>, can automatically detect the diagonal structure of gate tensors in a network and create the line graph of a network while taking the hypergraph structure of the network into account. We illustrate this below by creating the line graph for a network both with and without taking the hypergraph structure into account and show that using the hypergraph structure results in a smaller line graph. Below, the line graph is represented by the <a href="https://juliaqx.github.io/QXGraphDecompositions.jl/dev/LabeledGraph/">LabeledGraph</a> data structure implemented by the <code>QXGraphDecompositions</code> package. <code>@show</code>-ing this object should display the number of vertices and edges in the graph.</p><pre><code class="nohighlight hljs"># Create a random circuit.
tnc = TensorNetworkCircuit(3)
CX = [[1., 0., 0., 0.] [0., 1., 0., 0.] [0., 0., 0., 1.] [0., 0., 1., 0.]]

for layer = 1:10
    push!(tnc, [2, 1], CX)
    push!(tnc, [2, 3], CX)
    push!(tnc, [2], rand(2, 2))
end

# Create the line graph for the circuit without using the hypergraph.
# The number of vertices and edges are displayed respectively.
lg, symbol_map = convert_to_line_graph(tnc, use_hyperedges=false)
@show lg.graph

# Create the line graph for the circuit using the hypergraph.
lg, symbol_map = convert_to_line_graph(tnc, use_hyperedges=true)
@show lg.graph</code></pre><h2 id="Slicing"><a class="docs-heading-anchor" href="#Slicing">Slicing</a><a id="Slicing-1"></a><a class="docs-heading-anchor-permalink" href="#Slicing" title="Permalink"></a></h2><p>For simulations that use a contraction plan with a large treewidth, it may be the case that the simulation requires more memory than is available on the machine running the simulation. In this situation, it is necessary to reduce the memory requirements of the simulation.</p><p>The standard method for reducing the memory requirements of a simulation in exchange for greater time complexity is known as slicing. This method works by fixing the value of selected indices in the network to decompose the contraction of the network into the sum of contractions of smaller networks. For more details on this method see the section on slicing in <a href="https://arxiv.org/pdf/2005.06787.pdf">this</a> article.</p><p>For a given contraction plan for a tensor network, <code>QXTools</code> uses <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.062614">Shutski&#39;s tree-trimming</a>, which is implemented in the package <code>QXGraphDecompositions</code> to select efficient indices of a network to slice.</p><p>To find a contraction plan for a quantum circuit using flowcutter and then slice a specific number of indices using Shutski&#39;s tree trimming method, the convenience function <code>contraction_scheme</code> can be used and is demonstrated below.</p><pre><code class="nohighlight hljs"># Create a dummy circuit to test on.
N = 5
CX = [[1., 0., 0., 0.] [0., 1., 0., 0.] [0., 0., 0., 1.] [0., 0., 1., 0.]]
tnc = TensorNetworkCircuit(N)
for layer = 1:10, qubit = 1:N-1
    push!(tnc, [qubit, qubit+1], CX)
end
add_input!(tnc)

# Use FluwCutter for 10 seconds to find a contraction plan and then select 8 indices for slicing
# using the tree trimming method.
indices_to_slice, contraction_plan, metadata = contraction_scheme(tnc, 8; time=10, hypergraph=true)

println(&quot;The number of indices to be sliced is &quot;, length(indices_to_slice))
println(&quot;The treewidth as a function of the number of indices sliced is &quot;,
metadata[&quot;Slicing&quot;][&quot;Treewidths after slicing consecutive edges&quot;])</code></pre><h2 id="QXContexts-output"><a class="docs-heading-anchor" href="#QXContexts-output">QXContexts output</a><a id="QXContexts-output-1"></a><a class="docs-heading-anchor-permalink" href="#QXContexts-output" title="Permalink"></a></h2><p>The output of a distributed simulation run by <code>QXContexts</code> is determined by output parameters in the simulation files generated by the <code>generate_simulation_files</code> function in <code>QXTools</code>. To dictate which output is generated by <code>QXContexts</code>, a dictionary containing parameters for the desired output method needs to be passed to <code>generate_simulation_files</code>. To this end, <code>QXTools</code> provides the function <code>output_params_dict</code> which will create the relevant dictionary for the desired output. The tree output methods available in QXContexts are described below. Note, for each method, <code>output_params_dict</code> takes two positional arguments: <code>num_qubits</code> and <code>num_outputs</code> giving the number of qubits in the circuit to be simulated and the desired number of outputs to generate (ie number of bitstring samples or number of amplitudes to compute).</p><h3 id="Rejection"><a class="docs-heading-anchor" href="#Rejection">Rejection</a><a id="Rejection-1"></a><a class="docs-heading-anchor-permalink" href="#Rejection" title="Permalink"></a></h3><p>To generate random bitstrings, which are distributed as if they were measured on an ideal, noiseless quantum device running our quantum circuit, rejection sampling can be used. To create the output dictionary for rejection sampling, we can use the following keyword arguments of <code>output_params_dict</code>.</p><pre><code class="nohighlight hljs">num_qubits = 5
num_outputs = 5

output_params = output_params_dict(num_qubits, num_outputs;
                                    output_method = :Rejection,
                                    M = 0.0001,
                                    fix_M = false,
                                    seed = 42)</code></pre><p>Here, <code>M</code> is the parameter of rejection sampling that determines the average number of rejections made before a candidate output is accepted. <code>QXContexts</code> implements <a href="https://academic.oup.com/biomet/article-abstract/89/4/745/242234?redirectedFrom=fulltext">empirical supremum rejection sampling</a> where <code>M</code> should initially be chosen to be small and is subsequently updated to larger values (based on the largest probability amplitude computed) every iteration of the sampling method. Updates to the value of <code>M</code> may be disabled by setting <code>fix_M = true</code>. This is useful when a particular value of <code>M</code> is desired as is in <a href="https://arxiv.org/abs/1807.10749">frugal rejection sampling</a>.</p><h3 id="List"><a class="docs-heading-anchor" href="#List">List</a><a id="List-1"></a><a class="docs-heading-anchor-permalink" href="#List" title="Permalink"></a></h3><p>To compute the probability amplitudes for a list of bitstrings the list method can be used. In this case, we need only pass an array containing the bitstrings we want amplitudes for as a keyword argument to <code>output_params_dict</code>.</p><pre><code class="nohighlight hljs">num_qubits = 5
num_outputs = 3
bitstrings = [&quot;1111&quot;, &quot;1101&quot;, &quot;0101&quot;]

output_params = output_params_dict(num_qubits, num_outputs;
                                    output_method = :List,
                                    bitstrings = bitstrings)</code></pre><h3 id="Uniform"><a class="docs-heading-anchor" href="#Uniform">Uniform</a><a id="Uniform-1"></a><a class="docs-heading-anchor-permalink" href="#Uniform" title="Permalink"></a></h3><p>To compute the probability ampltiudes for a number of uniformly random bitstrings we can use the uniform method. The following will generate an outputs dictionary which will get <code>QXContexts</code> to generate <code>num_outputs</code> uniformaly random bitstrings for a quantum circuit with <code>num_qubits</code> qubits and compute probabiltiy amplitudes for them.</p><pre><code class="nohighlight hljs">num_qubits = 5
num_outputs = 3

output_params = output_params_dict(num_qubits, num_outputs;
                                    output_method = :Uniform,
                                    seed = 42)</code></pre><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>All paramters discussed above can be passed to the <code>generate_simulation_files</code> function. For a given <code>QXZoo</code> <code>circ</code> object, this function will create TensorNetworkCircuit object for the circuit, find a contraction plan for the associated tensor network using FlowCutter, determine the desired number of indices to slice and then generate a set of simulation files describing what output <code>QXContexts</code> should generate and how it should contract the relevant tensor networks. For the following example, it is assumed a <code>circ</code> object has already been created.</p><pre><code class="nohighlight hljs"># The prefix to be used for the names of the simulation files
output_prefix = &quot;my_cirq_sim&quot;

# Paramters for FlowCutter and the tree-trimming method for slicing.
time = 10
hypergraph = true
number_indices_to_slice = 8

# An output dictionary describing the desired output from the simulation.
num_qubits = circ.num_qubits; num_outputs = 15
output_args = output_params_dict(num_qubits, num_outputs; output_method = :Uniform, seed = 42)

# Generate the files describing how the simulation should be executed by QXContexts.
generate_simulation_files(circ,
                            output_prefix,
                            number_indices_to_slice;
                            seed = 42,
                            output_args = output_args,
                            time = time,
                            hypergraph = hypergraph)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../circuits/">« Circuits with QXZoo and YaoQX</a><a class="docs-footer-nextpage" href="../distributed/">Running Distributed Simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 14 December 2021 19:05">Tuesday 14 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
