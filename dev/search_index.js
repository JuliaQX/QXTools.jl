var documenterSearchIndex = {"docs":
[{"location":"users_guide/#User's-Guide","page":"User's Guide","title":"User's Guide","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"QXTools generates output files which provide a description of the computations and data required to perform a simulation. There are three output files:","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"Parameter file: This YAML file provides information on the sampling method to use for the simulation\nDSL file: The DSL file contains instructions describing the tensor operations involved in","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"performing the simulation. Uses .qx suffix","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"Data file: The data file contains the numerical values of the initial tensors of the tensor network","category":"page"},{"location":"users_guide/#Parallel-Processing","page":"User's Guide","title":"Parallel Processing","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"There are two levels of parallelism that are used to distribute computations over different processing elements. The highest level of parallism divides the set of output bitstrings among the available processing elements. The lower level of parallelism breaks each contraction into a sum of smaller contractions by slicing bonds of the tensor network. Slicing also reduces the total memory requirements and make it possible to perform contractions that would otherwise be intractable on a given system. However for each additional edge that is sliced, the network must be contracted for all possible values of the edge, leading to exponential growth in the number of contractions with the number of edges that are sliced. It is thus very important to choose the right edges to slice. This is a non trivial optimisation problem, but there exist many methods to which can find reasonable sets of edges to slice. In QXTools, the edges to slice are found when finding the contraciton plan which is handled by the QXGraphDecompositions package. Once the edges to select have been identified these appear as view commands in the DSL file, explained further below.","category":"page"},{"location":"users_guide/#Parameter-File","page":"User's Guide","title":"Parameter File","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The parameter file parameters for the sampling method used to select output bitstrings. The following example shows how an explicit list of 3 bitstrings can be provided.","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"output:\n  method: List\n  params:\n    num_samples: 3\n    bitstrings:\n      - \"010\"\n      - \"101\"\n      - \"111\"","category":"page"},{"location":"users_guide/#DSL-Specification","page":"User's Guide","title":"DSL Specification","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"A Domain Specific Language (DSL) has been defined when enables better separation of concerns between components. This DSL describes a contraction over a tensor network to calculate observables of interest in the form of a sequence of instructions which act on individual tensors. This makes it possible to separate the development of the high performance distributed tensor network computation code from that of the higher level contraction planning, circuit and and network manipulation code. The \".qx\" suffix is used to identify these DSL files. We will first show a simple example of such a DSL file and then descibe each instruction in detail.","category":"page"},{"location":"users_guide/#Example-DSL-file","page":"User's Guide","title":"Example DSL file","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"An example of the DSL generated for the contraction of a two qubit GHZ circuit looks like.","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"# version: 0.4.0\n# Determination of contraction plan:\n#   Method used: \"flow cutter\"\n#   Treewidth: 2\n#   Time allocated: 2\n#   Seed used: -1\n#   Returned metadata:\n#     1: \"c min degree heuristic\"\n#     2: \"c status 3 1627390755700\"\n#     3: \"c min shortcut heuristic\"\n#     4: \"c run with 0.0/0.1/0.2 min balance and node_min_expansion in endless loop with varying seed\"\n#   Hypergraph used: true\n#   Hyperedge contraction method: \"Netcon where possible, min fill heuristic otherwise.\"\n# Slicing:\n#   Method used: \"greedy treewidth deletion\"\n#   Edges sliced: 2\n#   Score fucntion used: direct_treewidth\n#   Treewidths after slicing consecutive edges:\n#     - 1\n#     - 0\n#\nload t5 data_1 2\nview t5_s t5 v2 1 2\nload t1 data_2 2,2\nview t1_s t1 v1 1 2\nload t4 data_1 2\nncon I2 1 t1_s 1,2 t4 2\nncon t8 1,2 t5_s 1 I2 2\nload t3 data_4 2\nview t3_s t3 v1 1 2\nncon t9 1,2 t8 1,2 t3_s 2\noutput t6 1 2\nview t6_s t6 v1 1 2\nncon t10 1,2 t9 1,2 t6_s 2\nload t2 data_3 2,2,2\nview t2_s t2 v1 3 2\nview t2_s_s t2_s v2 2 2\noutput t7 2 2\nncon I1 2,3 t2_s_s 1,2,3 t7 1\nncon t11 0 t10 1,2 I1 1,2\nsave output t11","category":"page"},{"location":"users_guide/#DSL-Format-and-Instructions","page":"User's Guide","title":"DSL Format and Instructions","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The DSL file is a regular ASCII text file with one instruction per line. Lines beginning with # are comments which are ignored (except for the first line which contains version information). The first line has a version string which specifies the format version. Comments following the first line contain metadata about the methods used to determine the contraction plan used and which edges to slice. We now go through each of the instructions in order of appearence.","category":"page"},{"location":"users_guide/#Load","page":"User's Guide","title":"Load","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"Load instructions define a new tensor symbol using data from the input file. Here the first argument is the name of the new symbol, the second argument is the key to find the data at and the third argument is a comma separated list of dimensions of the tensor.","category":"page"},{"location":"users_guide/#View","page":"User's Guide","title":"View","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The view instruction creates a new tensor symbol by taking a view of an existing tensor. The first argument is the new symbol name, the second is the symbol of the tensor to take the view of, the third argument is the symbol used to identify the index, the fourth identifies the rank of the index of the tensor to slice and the final argument is the dimension of the bond. For example the instruction","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"view t5_s t5 v2 1 2","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"will create a new tensor labeled t5_s by taking a view on the tensor labeled t5 by setting the value of the first index to the value labeled by symbol v2. If t5_s, t5 and v2 were variables this would look something like","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"t5_s = t5[v2]","category":"page"},{"location":"users_guide/#Contraction","page":"User's Guide","title":"Contraction","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The ncon instruction specifies a pairwise contraction of tensors. An example contraction command is as follows","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"ncon I2 1 t1_s 1,2 t4 2","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"Which indicates that the t1_s tensor should be contracted with the t4 tensor to get the I2 tensor. The contraction should be performed over the second rank of the t1_s tensor and first rank of the t4 tensor. Einstein summation notation is used for for specifying which indices to contract over. This convention uses repeated indices on the right hand side to indicate that those indices should be contracted over. In the above, the 2 index appears twice on the right hand side which indicates that this index should be contracted over. For the case where one of the tensors is a scalar, a 0 is used as a placeholder. For example if t1 is a scalar tensor and t2 is a matrix, the multiplication of the matrix by the scalar can be expressed as","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"ncon t3 1,2 t1 0 t2 1,2","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"Batched contractions (sometimes called hyper-contractions) are also supported. This is where the same index is repeated on the right hand side and also appears on the left hand side.","category":"page"},{"location":"users_guide/#Output","page":"User's Guide","title":"Output","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The output instruction marks tensors as corresponding to circuit outputs and provides their dimension. For example, the instruction","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"output t6 1 2","category":"page"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"specifies that the tensor t6 will refer to the first output and that it has dimension 2.","category":"page"},{"location":"users_guide/#Save","page":"User's Guide","title":"Save","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The save instruction indicates that the given tensor is an output from the contraction and provides a label for this. The value of this tensor will then be used in a reduction operation and/or written to the output file.","category":"page"},{"location":"users_guide/#Data-File","page":"User's Guide","title":"Data File","text":"","category":"section"},{"location":"users_guide/","page":"User's Guide","title":"User's Guide","text":"The data file is a JLD2 file and contains the numerical values of the initial tensors. Each tensor is stored as a multi-dimensional array with a data label that is referenced in load commands of the DSL file.","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"MIT License","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"Copyright (c) 2021 QuantEx team","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"LICENSE","title":"LICENSE","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"QXTools is a Julia package and can be installed using Julia's inbuilt package manager from the Julia REPL using.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"QXTools\")","category":"page"},{"location":"getting_started/#Example-usage","page":"Getting Started","title":"Example usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"An example of how QXTools can be used to calculate a set of amplitudes for small GHZ preparation circuit looks like","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using QXTools\nusing QXTools.Circuits\n\n# Create ghz circuit\ncirc = create_ghz_circuit(3)\n\n# Convert the circuit to a tensor network circuit\ntnc = convert_to_tnc(circ)\n\n# Find a good contraction plan\nplan = flow_cutter_contraction_plan(tnc; time=10)\n\n# Contract the network using this plan to find the given amplitude for different outputs\n@show QXTools.single_amplitude(tnc, plan, \"000\")\n@show QXTools.single_amplitude(tnc, plan, \"111\")\n@show QXTools.single_amplitude(tnc, plan, \"100\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is only recommended for small test cases. For larger scale runs one can call the generate_simulation_files which will do the conversion to a network, find the contraction plan and create output files describing the required calculations. For example","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using QXTools\nusing QXTools.Circuits\n\n# Create ghz circuit\ncirc = create_ghz_circuit(3)\n\ngenerate_simulation_files(circ, \"ghz_3\", time=10)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"will generate the files:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ghz_3.qx: A DSL file with instructions\nghz_3.jld2: A data file with intitial tensors\nghz_3.yml: A parameter file with parameters controlling the simulation","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"These can be used as input to QXContexts to run the simulation on distributed clusters.","category":"page"},{"location":"circuits/#Circuits-with-QXZoo-and-YaoQX","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"","category":"section"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"In the introduction tutorial circuits are constructed by explicitly defining each of the gate matrices. For larger circuits this can get tedious and it is easier to construct circuits using QXZoo or to convert circuits created using Yao.jl to TensorNetworkCircuits.","category":"page"},{"location":"circuits/#QXZoo","page":"Circuits with QXZoo and YaoQX","title":"QXZoo","text":"","category":"section"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"QXZoo was developed to simplify this process and provides functions for constructing commonly used circuits as well as primatives for building circuits from commonly used gate sets. QXTools wraps many of the functions from QXZoo to improve integration and provides a simple interface for creating Greenberger–Horne–Zeilinger (GHZ), Quantum Fourier Transform (QFT) and Random Quantum Circuits (RQC).","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"To create a GHZ circuit with 5 qubits one would use","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"using QXTools\ncirc = create_ghz_circuit(5)","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"This returns a QXZoo Circ struct which contains num_qubits and circ_ops data members giving the number of qubits and access to the gates respectively. QXTools provides gate_qubits and gate_matrix functions to simplify extracting the qubits that the gate acts upon and the matrix representation of the gate.","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"println(\"Circuit has $(circ.num_qubits) qubits\")\nfor g in circ.circ_ops\n    println(\"Gate acts on qubits $(gate_qubits(g))\")\n    println(\"Matrix form $(gate_matrix(g))\")\nend","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"QXTools provides the convert_to_tnc function which will convert a QXZoo circuit to a TensorNetworkCircuit","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"tnc = convert_to_tnc(circ)","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"The create_qft_circuit will create a QFT circuit when given the number of qubits.","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"circ = create_qft_circuit(5)","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"Finally the create_rqc_circuit creates a RQC circuit and takes arguments specifying the number of rows, columns, depth and the seed to use when sampling unitary gates. One can also specify whether or not to add a final layer of Hadamard which is sometimes ommitted.","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"circ = create_rqc_circuit(4, 4, 16, 42, final_h=true)","category":"page"},{"location":"circuits/#YaoQX","page":"Circuits with QXZoo and YaoQX","title":"YaoQX","text":"","category":"section"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"The YaoQX package provides a lightweight wrapper which enables circuits constructed using the Yao tools to be used with QXTools. YaoQX can be installed from the Julia package registry with","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"] add YaoQX","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"We also install YaoBlocks to allow us to construct Yao circuits.","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"] add YaoBlocks","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"The following is an example of creating a simple  3 qubit GHZ circuit with YaoBlocks and converting it to a QXTools TensorNetworkCircuit.","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"using YaoQX\nusing YaoBlocks\nn = 3\ncirc = chain(put(1=>H), chain(map(x -> control(n, x, x+1=>X), 1:n-1)...))","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"YaoQX implements the convert_to_tnc function for YaoBlocks circuits so these circuits can be converted to TensorNetworkCircuits in exactly the same way that QXZoo circuits can be with","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"tnc = convert_to_tnc(circ)","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"Note that the same arguments are supported so to convert to a TensorNetworkCircuit with no input or output one can add additional keyword arguments as","category":"page"},{"location":"circuits/","page":"Circuits with QXZoo and YaoQX","title":"Circuits with QXZoo and YaoQX","text":"tnc = convert_to_tnc(circ, no_input=true, no_output=true)","category":"page"},{"location":"features/#Miscellaneous-Features","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"In this tutorial we cover some of the features QXTools has to improve quantum circuit simulations and how to specify the type of output we would like our simulations to generate.","category":"page"},{"location":"features/#Hypergraphs","page":"Miscellaneous Features","title":"Hypergraphs","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"One feature that QXTools uses by default is that of hypergraphs. The hypergraph for a given tensor network is a graph, representing the network topology, whose nodes correspond to tensors in the network and edges correspond to indices in the network that connect different tensors. Note, two indices in the netwrok may be associated with the same edge in the hypergraph if they both connect to a diagonal tensor and are identical as a result. The tensor network topology can also be represented using an ordinary graph but it typically requires a greater number of edges to do so.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"This is useful because to find an efficient contraction plan for a given tensor network, QXTools first creates a line graph for the network topology and then runs the FlowCutter algorithm to find a tree decompostion for that line graph which can be converted into a contraction plan. Running FlowCutter on smaller graphs often results in more efficient contraction plans, with a smaller treewidth, in a shorter amount of time.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"QXTools, together with QXTns, can automatically detect the diagonal structure of gate tensors in a network and create the line graph of a network while taking the hypergraph structure of the network into account. We illustrate this below by creating the line graph for a network both with and without taking the hypergraph structure into account and show that using the hypergraph structure results in a smaller line graph. Below, the line graph is represented by the LabeledGraph data structure implemented by the QXGraphDecompositions package. @show-ing this object should display the number of vertices and edges in the graph.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"# Create a random circuit.\ntnc = TensorNetworkCircuit(3)\nCX = [[1., 0., 0., 0.] [0., 1., 0., 0.] [0., 0., 0., 1.] [0., 0., 1., 0.]]\n\nfor layer = 1:10\n    push!(tnc, [2, 1], CX)\n    push!(tnc, [2, 3], CX)\n    push!(tnc, [2], rand(2, 2))\nend\n\n# Create the line graph for the circuit without using the hypergraph.\n# The number of vertices and edges are displayed respectively.\nlg, symbol_map = convert_to_line_graph(tnc, use_hyperedges=false)\n@show lg.graph\n\n# Create the line graph for the circuit using the hypergraph.\nlg, symbol_map = convert_to_line_graph(tnc, use_hyperedges=true)\n@show lg.graph","category":"page"},{"location":"features/#Slicing","page":"Miscellaneous Features","title":"Slicing","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"For simulations that use a contraction plan with a large treewidth, it may be the case that the simulation requires more memory than is available on the machine running the simulation. In this situation, it is necessary to reduce the memory requirements of the simulation.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"The standard method for reducing the memory requirements of a simulation in exchange for greater time complexity is known as slicing. This method works by fixing the value of selected indices in the network to decompose the contraction of the network into the sum of contractions of smaller networks. For more details on this method see the section on slicing in this article.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"For a given contraction plan for a tensor network, QXTools uses Shutski's tree-trimming, which is implemented in the package QXGraphDecompositions to select efficient indices of a network to slice.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"To find a contraction plan for a quantum circuit using flowcutter and then slice a specific number of indices using Shutski's tree trimming method, the convenience function contraction_scheme can be used and is demonstrated below.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"# Create a dummy circuit to test on.\nN = 5\nCX = [[1., 0., 0., 0.] [0., 1., 0., 0.] [0., 0., 0., 1.] [0., 0., 1., 0.]]\ntnc = TensorNetworkCircuit(N)\nfor layer = 1:10, qubit = 1:N-1\n    push!(tnc, [qubit, qubit+1], CX)\nend\nadd_input!(tnc)\n\n# Use FluwCutter for 10 seconds to find a contraction plan and then select 8 indices for slicing\n# using the tree trimming method.\nindices_to_slice, contraction_plan, metadata = contraction_scheme(tnc, 8; time=10, hypergraph=true)\n\nprintln(\"The number of indices to be sliced is \", length(indices_to_slice))\nprintln(\"The treewidth as a function of the number of indices sliced is \",\nmetadata[\"Slicing\"][\"Treewidths after slicing consecutive edges\"])","category":"page"},{"location":"features/#QXContexts-output","page":"Miscellaneous Features","title":"QXContexts output","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"The output of a distributed simulation run by QXContexts is determined by output parameters in the simulation files generated by the generate_simulation_files function in QXTools. To dictate which output is generated by QXContexts, a dictionary containing parameters for the desired output method needs to be passed to generate_simulation_files. To this end, QXTools provides the function output_params_dict which will create the relevant dictionary for the desired output. The tree output methods available in QXContexts are described below. Note, for each method, output_params_dict takes two positional arguments: num_qubits and num_outputs giving the number of qubits in the circuit to be simulated and the desired number of outputs to generate (ie number of bitstring samples or number of amplitudes to compute).","category":"page"},{"location":"features/#Rejection","page":"Miscellaneous Features","title":"Rejection","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"To generate random bitstrings, which are distributed as if they were measured on an ideal, noiseless quantum device running our quantum circuit, rejection sampling can be used. To create the output dictionary for rejection sampling, we can use the following keyword arguments of output_params_dict.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"num_qubits = 5\nnum_outputs = 5\n\noutput_params = output_params_dict(num_qubits, num_outputs;\n                                    output_method = :Rejection,\n                                    M = 0.0001,\n                                    fix_M = false,\n                                    seed = 42)","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"Here, M is the parameter of rejection sampling that determines the average number of rejections made before a candidate output is accepted. QXContexts implements empirical supremum rejection sampling where M should initially be chosen to be small and is subsequently updated to larger values (based on the largest probability amplitude computed) every iteration of the sampling method. Updates to the value of M may be disabled by setting fix_M = true. This is useful when a particular value of M is desired as is in frugal rejection sampling.","category":"page"},{"location":"features/#List","page":"Miscellaneous Features","title":"List","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"To compute the probability amplitudes for a list of bitstrings the list method can be used. In this case, we need only pass an array containing the bitstrings we want amplitudes for as a keyword argument to output_params_dict.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"num_qubits = 5\nnum_outputs = 3\nbitstrings = [\"1111\", \"1101\", \"0101\"]\n\noutput_params = output_params_dict(num_qubits, num_outputs;\n                                    output_method = :List,\n                                    bitstrings = bitstrings)","category":"page"},{"location":"features/#Uniform","page":"Miscellaneous Features","title":"Uniform","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"To compute the probability ampltiudes for a number of uniformly random bitstrings we can use the uniform method. The following will generate an outputs dictionary which will get QXContexts to generate num_outputs uniformaly random bitstrings for a quantum circuit with num_qubits qubits and compute probabiltiy amplitudes for them.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"num_qubits = 5\nnum_outputs = 3\n\noutput_params = output_params_dict(num_qubits, num_outputs;\n                                    output_method = :Uniform,\n                                    seed = 42)","category":"page"},{"location":"features/#Example","page":"Miscellaneous Features","title":"Example","text":"","category":"section"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"All paramters discussed above can be passed to the generate_simulation_files function. For a given QXZoo circ object, this function will create TensorNetworkCircuit object for the circuit, find a contraction plan for the associated tensor network using FlowCutter, determine the desired number of indices to slice and then generate a set of simulation files describing what output QXContexts should generate and how it should contract the relevant tensor networks. For the following example, it is assumed a circ object has already been created.","category":"page"},{"location":"features/","page":"Miscellaneous Features","title":"Miscellaneous Features","text":"# The prefix to be used for the names of the simulation files\noutput_prefix = \"my_cirq_sim\"\n\n# Paramters for FlowCutter and the tree-trimming method for slicing.\ntime = 10\nhypergraph = true\nnumber_indices_to_slice = 8\n\n# An output dictionary describing the desired output from the simulation.\nnum_qubits = circ.num_qubits; num_outputs = 15\noutput_args = output_params_dict(num_qubits, num_outputs; output_method = :Uniform, seed = 42)\n\n# Generate the files describing how the simulation should be executed by QXContexts.\ngenerate_simulation_files(circ,\n                            output_prefix,\n                            number_indices_to_slice;\n                            seed = 42,\n                            output_args = output_args,\n                            time = time,\n                            hypergraph = hypergraph)","category":"page"},{"location":"basics/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"In this tutorial, we will cover the basics of creating a simple quantum circuit, using only primitive operations defined by QXTools, and contracting its' associated tensor network to compute a probability amplitude for a bitstrings we might see when the qubits are measured at the end of the circuit. We begin by importing the QXTools package:","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"using QXTools","category":"page"},{"location":"basics/#Creating-a-TensorNetworkCircuit","page":"Introduction","title":"Creating a TensorNetworkCircuit","text":"","category":"section"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"QXTools uses objects called TensorNetworkCircuit to represent quantum circuits. A TensorNetworkCircuit contains a tensor network, representing the output state of the the circuit's qubits, as one of its field. We can create a TensorNetworkCircuit for an empty quantum circuit by calling the TensorNetworkCircuit constructor with the number of qubits we want in the circuit. Below we create an empty 3 qubit circuit with no gates.","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"tnc = TensorNetworkCircuit(3)","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"We can add a single qubit gate to our circuit by passing the matrix representation of the gate to the Base.push! function. We also need to specify which qubit we want the gate to act on as shown below.  Note, the qubits in the circuit are numbered 1 to N where N is the number of qubits in the circuit.","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"X = [[0., 1.] [1., 0.]]\n\n# Apply an X gate to both the first and third qubits in the circuit.\npush!(tnc, [1], X)\npush!(tnc, [3], X)","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"Similarly, to add a two qubit gate we can pass the matrix representation of the gate to the push! function, along with an array of integers indicating the target qubits we want the gate to act on. Note, the order of the target qubits is fixed by the given matrix representation of the gate.","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"# Matrix representation of the controlled not gate.\nCX = [[1., 0., 0., 0.] [0., 1., 0., 0.] [0., 0., 0., 1.] [0., 0., 1., 0.]]\n\n# Note, for the given matrix representation of the CX gate\n# the order of the qubits here is [target, control].\npush!(tnc, [1, 2], CX)","category":"page"},{"location":"basics/#Contracting-a-TensorNetworkCircuit.","page":"Introduction","title":"Contracting a TensorNetworkCircuit.","text":"","category":"section"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"After creating a TensorNetworkCircuit, we may then want to compute the probability amplitude for a particular bitstring. To compute amplitudes for different measurement outcomes, we first set the initial state of the qubits in the circuit. This can be done using the add_inputs! function. For example, calling add_inputs!(tnc, \"111\") will add tensors to the tensor network which set the initial state of the circuit's qubits to the basis state labeled by \"111\". By default, calling add_inputs!(tnc) will set the initial qubit state to the \"all zeros\" state.","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"# Set the initial state of the qubits to \"000\".\nadd_input!(tnc)","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"Next, we need to calculate a contraction plan for the tensor network. A contraction plan for a TensorNetworkCircuit determines the order in which tensors in the network are contracted to compute a probability amplitude. With QXTools, we can compute a contraction plan using an algorithm known as FlowCutter for a set amount of time. Below, we run FlowCutter 1 second to find a contraction plan for our quantum circuit.","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"# Find a good contraction plan.\nplan = flow_cutter_contraction_plan(tnc; time=1)","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"We can now compute probabiliy amplitudes using the single_amplitude function. Calling this function on our TensorNetworkCircuit object, its contraction plan and a string, indicating a product state of the qubits, will result in a copy of the circuit's tensor network being contracted according to the given contraction plan and the desired probability amplitude being returned. Note, the characters in the string give the states of the individual qubits in ascending order such that the first character in the string gives the state of the first qubit in the circuit etc.","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"# Contract the network using this plan to find the given amplitude for different outputs.\n@show single_amplitude(tnc, plan, \"000\")\n@show single_amplitude(tnc, plan, \"101\")\n\n# The `+` and `-` characters are also supported to represent the states (\"0\" + \"1\") and (\"0\" - \"1\") respectively.\n@show single_amplitude(tnc, plan, \"1++\")","category":"page"},{"location":"basics/","page":"Introduction","title":"Introduction","text":"Contracting a network with the simple_amplitude function will contract the network using the QXTns package. This works well for small networks and for retrieving the amplitudes of one bitstring at a time. For more complex networks and output sampling methods we instead use the QXContexts package which provides more advanced sampling tools and supports distributed simulation as well as the use of GPU accelerators. The workflow for using QXContexts to contract networks is described in the Running Distributed Simulations tutorial.","category":"page"},{"location":"distributed/#Running-Distributed-Simulations","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"","category":"section"},{"location":"distributed/#Generating-input-files","page":"Running Distributed Simulations","title":"Generating input files","text":"","category":"section"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"To use QXContexts we first generate a set of input files using the generate_simulation_files function. This function accepts any circuit type for which the convert_to_tnc function has been implemented. This includes QXZoo and YaoBlocks circuits, see the Circuits with QXZoo and YaoQX tutorial for more details on creating such circuits. The following example will use a 49 qubit Random Quantum Circuit (RQC) of depth 16.","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"using QXTools\n\ncirc = create_rqc_circuit(7, 7, 16, 42, final_h=true)\noutput_args = output_params_dict(49, 100)\ngenerate_simulation_files(circ, \"rqc_7_7_16\", time=10, output_args=output_args)","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"The above example will run the contraction finding algorithm for 10 seconds and write input files rqc_7_7_16.qx, rqc_7_7_16.yaml and rqc_7_7_16.jld2. By default two bonds will be sliced and the simulation files will specify that simulation should be run for 100 random bitstrings. Further details on the format and contents of these files is described in the User Guide and further details of the slicing and output sampling options of the generate_simulation_files function are described in the Miscellaneous Features tutorial.","category":"page"},{"location":"distributed/#Running-the-simulation","page":"Running Distributed Simulations","title":"Running the simulation","text":"","category":"section"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"Once the input files have been generated, simulations can be run using the bin/qxrun.jl script which can be run directly from the command line (not the Julia REPL). To run a simulation using the input files generated in the example above one would use","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"julia --project bin/qxrun.jl -d rqc_7_7_16.qx -o rqc_7_7_16_output.jld2","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"This will run the simulation and write the output to the rqc_7_7_16_output.jld2 file.","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"To run simulations in parallel the MPI.jl package must first be installed and the mpiexecjl utility installed. This can be done with the following commands:","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"]add MPI\nimport MPI\nMPI.install_mpiexecjl()","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"On compute clusters it is advised to use the system provided MPI installation. For more details on this see the official MPI.jl documentation here.","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"Once MPI.jl has been installed and configured the simulation example described above can be run in parallel on two processes with","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"mpiexecjl --project -n 2 julia  bin/qxrun.jl -d rqc_7_7_16.qx -o rqc_7_7_16_output.jld2 -m","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"where the -n 2 specifies the number of processes to use and the -m option enabled MPI.","category":"page"},{"location":"distributed/#Measuring-the-time-and-speedup","page":"Running Distributed Simulations","title":"Measuring the time and speedup","text":"","category":"section"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"When running the above example we would expect to see a reduction in the time taken when using more processes, however this is not what we observe in practice. This is due to the fact that with Julia when running code for the first time the majority of the time is taken up by compilation. In the above example since we are only calculating amplitudes for 10 bitstrings there are not enough computations after this compilation to observe a speedup. In practice for circuits of this size one would be calculating amplitudes for millions of bitstrings. It is also possible to reduce this startup time by compiling a custom system image as decribed in this documentation for QXContexts.","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"To see more clearly the time taken for compilation vs computation one can run the examples above using the -t flag. When this flag is used the simulation will be performed twice and timing information collected from each of these runs. (We also add -b 1 which sets the number of BLAS threads to 1 to see clearly the effect of increasing the number of processes without changing the contention between cores that would result when threading is also used.) Using a single process with the following command","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"mpiexecjl --project -n 1 julia bin/qxrun.jl -d rqc_7_7_16.qx -o rqc_7_7_16_output.jld2 -m  -t -b 1","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"results in the following timing output","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":" ──────────────────────────────────────────────────────────────────────────────\n                                       Time                   Allocations\n                               ──────────────────────   ───────────────────────\n       Tot / % measured:          1127914s / 0.01%          15.5GiB / 90.5%\n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n Simulation                 1    52.6s  80.5%   52.6s   13.0GiB  93.0%  13.0GiB\n Init sampler               1    10.7s  16.3%   10.7s    759MiB  5.29%   759MiB\n   Parse input files        1    7.80s  11.9%   7.80s    562MiB  3.91%   562MiB\n   Create Context           1    1.34s  2.05%   1.34s    147MiB  1.03%   147MiB\n   Create sampler           1   73.5ms  0.11%  73.5ms   3.88MiB  0.03%  3.88MiB\n Write results              1    2.12s  3.24%   2.12s    251MiB  1.75%   251MiB\n ──────────────────────────────────────────────────────────────────────────────\n ──────────────────────────────────────────────────────────────────────────────\n                                       Time                   Allocations\n                               ──────────────────────   ───────────────────────\n       Tot / % measured:            16.1s / 100%            5.95GiB / 100%\n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n Simulation                 1    16.0s   100%   16.0s   5.94GiB  100%   5.94GiB\n Init sampler               1   60.2ms  0.37%  60.2ms   11.8MiB  0.19%  11.8MiB\n   Parse input files        1   41.5ms  0.26%  41.5ms   4.80MiB  0.08%  4.80MiB\n   Create Context           1   15.6ms  0.10%  15.6ms   6.78MiB  0.11%  6.78MiB\n   Create sampler           1   69.3μs  0.00%  69.3μs   2.08KiB  0.00%  2.08KiB\n Write results              1   1.60ms  0.01%  1.60ms   72.1KiB  0.00%  72.1KiB\n ──────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"The first set of timings include the precompilation whereas the second set are for the computations alone.  From this we see that the simulation part of the code took 16 seconds when using a single process.  Running on two processes with","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"mpiexecjl --project -n 2 julia bin/qxrun.jl -d rqc_7_7_16.qx -o rqc_7_7_16_output.jld2 -m  -t -b 1","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"we get","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":" ──────────────────────────────────────────────────────────────────────────────\n                                       Time                   Allocations\n                               ──────────────────────   ───────────────────────\n       Tot / % measured:          1129782s / 0.01%          12.5GiB / 88.2%\n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n Simulation                 1    46.5s  78.7%   46.5s   10.1GiB  91.1%  10.1GiB\n Init sampler               1    10.5s  17.7%   10.5s    759MiB  6.72%   759MiB\n   Parse input files        1    7.62s  12.9%   7.62s    562MiB  4.97%   562MiB\n   Create Context           1    1.36s  2.31%   1.36s    147MiB  1.30%   147MiB\n   Create sampler           1   74.0ms  0.13%  74.0ms   3.88MiB  0.03%  3.88MiB\n Write results              1    2.10s  3.57%   2.10s    251MiB  2.22%   251MiB\n ──────────────────────────────────────────────────────────────────────────────\n ──────────────────────────────────────────────────────────────────────────────\n                                       Time                   Allocations\n                               ──────────────────────   ───────────────────────\n       Tot / % measured:            8.53s / 100%            2.98GiB / 100%\n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n Simulation                 1    8.45s  99.0%   8.45s   2.97GiB  100%   2.97GiB\n Init sampler               1   79.9ms  0.94%  79.9ms   11.8MiB  0.39%  11.8MiB\n   Parse input files        1   38.2ms  0.45%  38.2ms   4.80MiB  0.16%  4.80MiB\n   Create Context           1   17.0ms  0.20%  17.0ms   6.78MiB  0.22%  6.78MiB\n   Create sampler           1   27.5μs  0.00%  27.5μs   2.08KiB  0.00%  2.08KiB\n Write results              1   2.43ms  0.03%  2.43ms   72.1KiB  0.00%  72.1KiB\n ──────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"where we see that the simulation only took 8.45s, almost half the time. Running for four processes with","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"mpiexecjl --project -n 4 julia bin/qxrun.jl -d rqc_7_7_16.qx -o rqc_7_7_16_output.jld2 -m  -t -b 1","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"results in","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":" ──────────────────────────────────────────────────────────────────────────────\n                                       Time                   Allocations\n                               ──────────────────────   ───────────────────────\n       Tot / % measured:          1128856s / 0.01%          11.0GiB / 86.6%\n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n Simulation                 1    55.6s  79.7%   55.6s   8.57GiB  89.7%  8.57GiB\n Init sampler               1    12.0s  17.2%   12.0s    759MiB  7.76%   759MiB\n   Parse input files        1    8.58s  12.3%   8.58s    562MiB  5.74%   562MiB\n   Create Context           1    1.60s  2.30%   1.60s    147MiB  1.50%   147MiB\n   Create sampler           1   88.1ms  0.13%  88.1ms   3.88MiB  0.04%  3.88MiB\n Write results              1    2.11s  3.03%   2.11s    251MiB  2.57%   251MiB\n ──────────────────────────────────────────────────────────────────────────────\n ──────────────────────────────────────────────────────────────────────────────\n                                       Time                   Allocations\n                               ──────────────────────   ───────────────────────\n       Tot / % measured:            4.63s / 100%            1.50GiB / 100%\n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n Simulation                 1    4.56s  98.5%   4.56s   1.48GiB  99.2%  1.48GiB\n Init sampler               1   68.9ms  1.49%  68.9ms   11.8MiB  0.77%  11.8MiB\n   Parse input files        1   46.3ms  1.00%  46.3ms   4.80MiB  0.31%  4.80MiB\n   Create Context           1   17.9ms  0.39%  17.9ms   6.78MiB  0.44%  6.78MiB\n   Create sampler           1   22.6μs  0.00%  22.6μs   2.08KiB  0.00%  2.08KiB\n Write results              1   2.01ms  0.04%  2.01ms   72.1KiB  0.00%  72.1KiB\n  ──────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"distributed/","page":"Running Distributed Simulations","title":"Running Distributed Simulations","text":"which shows the simulation taking 4.56s, almost half again. This shows that we achieve approximately linear speedup in the time taken for the actual simulation with increasing numbers of processes. For some scaling to larger numbers of processes see the results included in arXiv:2110.09894.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QXTools","category":"page"},{"location":"#QXTools","page":"Home","title":"QXTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QXTools is a Julia package for simulating quantum circuits using tensor network approaches. It targets large distributed memory clusters with hardware accelerators. It was developed as part of the QuantEx project, one of the individual software projects of WP8 of PRACE 6IP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QXTools ties together a number of other Julia packages which are also part of the QuantEx project. These include QXZoo for generating and manipulating quantum circuits, QXTns for representing and manipulating tensor networks, QXGraphDecompositions which implements a number of graph algorithms for finding good contraction plans and finally QXContexts which is designed to run on large distributed clusters and carry out the computations using input files generated using QXTools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The design and implementation of QXTools and related packages was inspired by many other frameworks and packages including ITensors, TensorOperations.jl, OMEinsum.jl, Yao.jl, TAL-SH and ExaTN.","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As quantum processing devices continue to scale and the algorithms and experiments being run on them grow in complexity, simulations of these systems become much more computationally demanding. To reduce the turnaround time and allow larger systems to be simulated it is necessary to move beyond single workstations and use distributed compute clusters. QXTools provides a flexible, extensible open source framework for performing these simulations. The use of Julia makes it easy for the code to be understood, modified and extended while not sacrificing performance compared to compiled languages.","category":"page"},{"location":"#Where-to-begin","page":"Home","title":"Where to begin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For getting QXTools installed and setup, see the Getting Started section which has instructions on how to install QXTools and some hello world examples. The \"Tutorials\" section contains some more in-depth examples and the \"Users Guide\" has more details of the design and structure of QXTools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"users_guide.md\"]\nDepth = 2","category":"page"}]
}
