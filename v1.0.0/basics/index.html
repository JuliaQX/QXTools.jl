<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · QXTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaQX.github.io/QXTools.jl/basics/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QXTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QXTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../users_guide/">User&#39;s Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-TensorNetworkCircuit"><span>Creating a TensorNetworkCircuit</span></a></li><li><a class="tocitem" href="#Contracting-a-TensorNetworkCircuit."><span>Contracting a TensorNetworkCircuit.</span></a></li></ul></li><li><a class="tocitem" href="../circuits/">Circuits with QXZoo and YaoQX</a></li><li><a class="tocitem" href="../features/">Miscellaneous Features</a></li><li><a class="tocitem" href="../distributed/">Running Distributed Simulations</a></li></ul></li><li><a class="tocitem" href="../license/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQX/QXTools.jl/blob/master/docs/src/basics.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>In this tutorial, we will cover the basics of creating a simple quantum circuit, using only primitive operations defined by <code>QXTools</code>, and contracting its&#39; associated tensor network to compute a probability amplitude for a bitstrings we might see when the qubits are measured at the end of the circuit. We begin by importing the <code>QXTools</code> package:</p><pre><code class="nohighlight hljs">using QXTools</code></pre><h2 id="Creating-a-TensorNetworkCircuit"><a class="docs-heading-anchor" href="#Creating-a-TensorNetworkCircuit">Creating a TensorNetworkCircuit</a><a id="Creating-a-TensorNetworkCircuit-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-TensorNetworkCircuit" title="Permalink"></a></h2><p><code>QXTools</code> uses objects called <code>TensorNetworkCircuit</code> to represent quantum circuits. A <code>TensorNetworkCircuit</code> contains a tensor network, representing the output state of the the circuit&#39;s qubits, as one of its field. We can create a <code>TensorNetworkCircuit</code> for an empty quantum circuit by calling the <code>TensorNetworkCircuit</code> constructor with the number of qubits we want in the circuit. Below we create an empty 3 qubit circuit with no gates.</p><pre><code class="nohighlight hljs">tnc = TensorNetworkCircuit(3)</code></pre><p>We can add a single qubit gate to our circuit by passing the matrix representation of the gate to the <code>Base.push!</code> function. We also need to specify which qubit we want the gate to act on as shown below.  Note, the qubits in the circuit are numbered 1 to N where N is the number of qubits in the circuit.</p><pre><code class="nohighlight hljs">X = [[0., 1.] [1., 0.]]

# Apply an X gate to both the first and third qubits in the circuit.
push!(tnc, [1], X)
push!(tnc, [3], X)</code></pre><p>Similarly, to add a two qubit gate we can pass the matrix representation of the gate to the <code>push!</code> function, along with an array of integers indicating the target qubits we want the gate to act on. Note, the order of the target qubits is fixed by the given matrix representation of the gate.</p><pre><code class="nohighlight hljs"># Matrix representation of the controlled not gate.
CX = [[1., 0., 0., 0.] [0., 1., 0., 0.] [0., 0., 0., 1.] [0., 0., 1., 0.]]

# Note, for the given matrix representation of the CX gate
# the order of the qubits here is [target, control].
push!(tnc, [1, 2], CX)</code></pre><h2 id="Contracting-a-TensorNetworkCircuit."><a class="docs-heading-anchor" href="#Contracting-a-TensorNetworkCircuit.">Contracting a TensorNetworkCircuit.</a><a id="Contracting-a-TensorNetworkCircuit.-1"></a><a class="docs-heading-anchor-permalink" href="#Contracting-a-TensorNetworkCircuit." title="Permalink"></a></h2><p>After creating a <code>TensorNetworkCircuit</code>, we may then want to compute the probability amplitude for a particular bitstring. To compute amplitudes for different measurement outcomes, we first set the initial state of the qubits in the circuit. This can be done using the <code>add_inputs!</code> function. For example, calling <code>add_inputs!(tnc, &quot;111&quot;)</code> will add tensors to the tensor network which set the initial state of the circuit&#39;s qubits to the basis state labeled by &quot;111&quot;. By default, calling <code>add_inputs!(tnc)</code> will set the initial qubit state to the &quot;all zeros&quot; state.</p><pre><code class="nohighlight hljs"># Set the initial state of the qubits to &quot;000&quot;.
add_input!(tnc)</code></pre><p>Next, we need to calculate a contraction plan for the tensor network. A contraction plan for a <code>TensorNetworkCircuit</code> determines the order in which tensors in the network are contracted to compute a probability amplitude. With <code>QXTools</code>, we can compute a contraction plan using an algorithm known as FlowCutter for a set amount of time. Below, we run FlowCutter 1 second to find a contraction plan for our quantum circuit.</p><pre><code class="nohighlight hljs"># Find a good contraction plan.
plan = flow_cutter_contraction_plan(tnc; time=1)</code></pre><p>We can now compute probabiliy amplitudes using the <code>single_amplitude</code> function. Calling this function on our <code>TensorNetworkCircuit</code> object, its contraction plan and a string, indicating a product state of the qubits, will result in a copy of the circuit&#39;s tensor network being contracted according to the given contraction plan and the desired probability amplitude being returned. Note, the characters in the string give the states of the individual qubits in ascending order such that the first character in the string gives the state of the first qubit in the circuit etc.</p><pre><code class="nohighlight hljs"># Contract the network using this plan to find the given amplitude for different outputs.
@show single_amplitude(tnc, plan, &quot;000&quot;)
@show single_amplitude(tnc, plan, &quot;101&quot;)

# The `+` and `-` characters are also supported to represent the states (&quot;0&quot; + &quot;1&quot;) and (&quot;0&quot; - &quot;1&quot;) respectively.
@show single_amplitude(tnc, plan, &quot;1++&quot;)</code></pre><p>Contracting a network with the <code>simple_amplitude</code> function will contract the network using the <a href="https://github.com/JuliaQX/QXTns.jl">QXTns</a> package. This works well for small networks and for retrieving the amplitudes of one bitstring at a time. For more complex networks and output sampling methods we instead use the <a href="https://github.com/JuliaQX/QXContexts.jl">QXContexts</a> package which provides more advanced sampling tools and supports distributed simulation as well as the use of GPU accelerators. The workflow for using QXContexts to contract networks is described in the <a href="../distributed/">Running Distributed Simulations</a> tutorial.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../users_guide/">« User&#39;s Guide</a><a class="docs-footer-nextpage" href="../circuits/">Circuits with QXZoo and YaoQX »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 15 February 2022 15:10">Tuesday 15 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
